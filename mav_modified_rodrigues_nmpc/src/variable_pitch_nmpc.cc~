/*
 Copyright (c) 2015, Mina Kamel, ASL, ETH Zurich, Switzerland

 You can contact the author at <mina.kamel@mavt.ethz.ch>

 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 * Neither the name of ETHZ-ASL nor the
 names of its contributors may be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL ETHZ-ASL BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <mav_variable_pitch_nmpc/variable_pitch_nmpc.h>
#include <math.h>

#define PI 3.14159265

namespace mav_control {

constexpr double NonlinearModelPredictiveControl::kGravity;
constexpr int NonlinearModelPredictiveControl::kDisturbanceSize;

NonlinearModelPredictiveControl::NonlinearModelPredictiveControl(const ros::NodeHandle& nh,
                                                                 const ros::NodeHandle& private_nh)
    : nh_(nh),
      private_nh_(private_nh),
      initialized_parameters_(false),
      position_error_integration_(0, 0, 0),
      mpc_queue_(nh, private_nh, ACADO_N+1),
      command_f1_f2_f3_f4_(0, 0, 0, 0),
     // disturbance_observer_(nh, private_nh),
      verbose_(false),
      solve_time_average_(0),
      received_first_odometry_(false)
{

  acado_initializeSolver();

  W_.setZero();
  WN_.setZero();

  input_.setZero();
  state_.setZero();
  reference_.setZero();
  referenceN_.setZero();

  reset_integrator_service_server_ = nh_.advertiseService(
      "reset_integrator", &NonlinearModelPredictiveControl::resetIntegratorServiceCallback, this); // do we need this?

  initializeParameters();

  mpc_queue_.initializeQueue(sampling_time_, prediction_sampling_time_); //what is this for?

} // end of constructor

NonlinearModelPredictiveControl::~NonlinearModelPredictiveControl()
{

}

 
bool NonlinearModelPredictiveControl::resetIntegratorServiceCallback(std_srvs::Empty::Request &req,
                                                                     std_srvs::Empty::Response &res)
{
  position_error_integration_.setZero();
  return true;
} 


//initializing onlineData parameters
void NonlinearModelPredictiveControl::initializeParameters()
{
 // std::vector<double> drag_coefficients;
	//double  drag_coefficient;
	std::vector<double> inertia;

  //Get parameters from RosParam server
  private_nh_.param<bool>("verbose", verbose_, false);

  // Should we also do sanity check for loading of length of arm and yaw_ref from rosparam?
  if (!private_nh_.getParam("mass", mass_)) {
    ROS_ERROR("mass in nonlinear MPC controller is not loaded from ros parameter "
              "server");
    abort();
  }

  /* if (!private_nh_.getParam("roll_time_constant", roll_time_constant_)) {
    ROS_ERROR(
        "roll_time_constant in nonlinear MPC controller is not loaded from ros parameter server");
    abort();
  }

  if (!private_nh_.getParam("roll_gain", roll_gain_)) {
    ROS_ERROR("roll_gain in nonlinear MPC controller is not loaded from ros parameter server");
    abort();
  }

  if (!private_nh_.getParam("pitch_time_constant", pitch_time_constant_)) {
    ROS_ERROR(
        "pitch_time_constant in nonlinear MPC controller is not loaded from ros parameter server");
    abort();
  }

  if (!private_nh_.getParam("pitch_gain", pitch_gain_)) {
    ROS_ERROR("pitch_gain in nonlinear MPC controller is not loaded from ros parameter server");
    abort();
  } */

  if (!private_nh_.getParam("inertia", inertia)) {
	  ROS_ERROR(
		  "inertia in nonlinear MPC controller is not loaded from ros parameter server");
	  abort();
  }

  inertia_ << inertia.at(0), inertia.at(1), inertia.at(2);

  if (!private_nh_.getParam("drag_coefficient", drag_coefficient_)) {
    ROS_ERROR(
        "drag_coefficient in nonlinear MPC controller is not loaded from ros parameter server");
    abort();
  }
  //  drag_coefficients_ << drag_coefficients.at(0), drag_coefficients.at(1), drag_coefficients.at(2);

   if (!private_nh_.getParam("armlength", armlength_)) {
	  ROS_ERROR("armlength in nonlinear MPC controller is not loaded from ros parameter "
		  "server");
	  abort();
  }

 if (!private_nh_.getParam("antiwindup_ball", antiwindup_ball_)) {
    ROS_ERROR(
        "antiwindup_ball in nonlinear MPC controller is not loaded from ros parameter server");
    abort();
  }

  if (!private_nh_.getParam("position_error_integration_limit",
                            position_error_integration_limit_)) {
    ROS_ERROR(
        "position_error_integration_limit in nonlinear MPC is not loaded from ros parameter server");
    abort();
  }


  if (!private_nh_.getParam("sampling_time", sampling_time_)) {
    ROS_ERROR("sampling_time in nonlinear MPC is not loaded from ros parameter server");
    abort();
  }

  if (!private_nh_.getParam("prediction_sampling_time", prediction_sampling_time_)) {
    ROS_ERROR("prediction_sampling_time in nonlinear MPC is not loaded from ros parameter server");
    abort();
  }

  for (int i = 0; i < ACADO_N + 1; i++) {
    acado_online_data_.block(i, 0, 1, ACADO_NOD) << mass_, inertia_(0), inertia_(1), inertia_(2), drag_coefficient_, armlength_, 0, 0, 0, 0; //zero for yaw_ref_.front() and external forces
  }

  Eigen::Map<Eigen::Matrix<double, ACADO_NOD, ACADO_N + 1>>(const_cast<double*>(acadoVariables.od)) =
      acado_online_data_.transpose();

  if (verbose_) {
    std::cout << "acado online data: " << std::endl << acado_online_data_ << std::endl;
  }

  initialized_parameters_ = true;
  ROS_INFO("Nonlinear MPC: initialized correctly");
}

//applying dyn config parameters
void NonlinearModelPredictiveControl::applyParameters()
{
  W_.block(0, 0, 3, 3) = q_position_.asDiagonal();
  W_.block(3, 3, 3, 3) = q_velocity_.asDiagonal();
  W_.block(6, 6, 3, 3) = q_attitude_.asDiagonal();
  W_.block(9, 9, 3, 3) = q_angVel_.asDiagonal();
  W_.block(12, 12, 4, 4) = r_command_.asDiagonal();

  /*WN_ = solveCARE((Eigen::VectorXd(6) << q_position_, q_velocity_).finished().asDiagonal(),
                  r_command_.asDiagonal());*/

  WN_.block(0, 0, 3, 3) = q_position_.asDiagonal(); // Or add different terminal penalties in dynamic config file
  WN_.block(3, 3, 3, 3) = q_velocity_.asDiagonal();

  Eigen::Map<Eigen::Matrix<double, ACADO_NY, ACADO_NY>>(const_cast<double*>(acadoVariables.W)) = W_.transpose();
  Eigen::Map<Eigen::Matrix<double, ACADO_NYN, ACADO_NYN>>(const_cast<double*>(acadoVariables.WN)) = WN_.transpose();

  for (size_t i = 0; i < ACADO_N; ++i) {
	  /* acadoVariables.lbValues[3 * i] = -roll_limit_;       // min roll
    acadoVariables.lbValues[3 * i + 1] = -pitch_limit_;  // min pitch
    acadoVariables.lbValues[3 * i + 2] = thrust_min_;    // min thrust
    acadoVariables.ubValues[3 * i] = roll_limit_;        // max roll
    acadoVariables.ubValues[3 * i + 1] = pitch_limit_;   // max pitch
    acadoVariables.ubValues[3 * i + 2] = thrust_max_;    // max thrust */
	  acadoVariables.lbValues[i] = force_min_;
	  acadoVariables.ubValues[i] = force_max_;
  }

  if (verbose_) {
    std::cout << "q_position_: " << q_position_.transpose() << std::endl;
    std::cout << "q_velocity_: " << q_velocity_.transpose() << std::endl;
	std::cout << "q_attitude_: " << q_attitude_.transpose() << std::endl;
	std::cout << "q_angVel_: " << q_angVel_.transpose() << std::endl;
    std::cout << "r_command_: " << r_command_.transpose() << std::endl;
    std::cout << "W_N = \n" << WN_ << std::endl;
  }
}

void NonlinearModelPredictiveControl::setOdometry(const mav_msgs::EigenOdometry& odometry)
{
  mpc_queue_.updateQueue();
  mpc_queue_.getQueue(position_ref_, velocity_ref_, acceleration_ref_, yaw_ref_, yaw_rate_ref_);
 
  //if (verbose_) { 
 //	std::cout << "z position reference: " << std::endl << position_ref_ << std::endl;
   //      }

  for (int i = 0; i < ACADO_N + 1; i++) {
	  acado_online_data_.block(i, ACADO_NOD-4, 1, 1) << yaw_ref_.front(); // OR yaw_ref_.at(i) ????
  }

  static mav_msgs::EigenOdometry previous_odometry = odometry;

  Eigen::Quaterniond quat_desired(cos(yaw_ref_.front() / 2), 0, 0, sin(yaw_ref_.front() / 2)); //what about yaw_ref trajectory?


  if (odometry.position_W.allFinite() == false) {
    odometry_.position_W = previous_odometry.position_W;
    ROS_WARN("Odometry.position has a non finite element");
  } else {
    odometry_.position_W = odometry.position_W;
    previous_odometry.position_W = odometry.position_W; //
  }

  if (odometry.velocity_B.allFinite() == false) {
    odometry_.velocity_B = previous_odometry.velocity_B;
    ROS_WARN("Odometry.velocity has a non finite element");
  } else {
    odometry_.velocity_B = odometry.velocity_B;
    previous_odometry.velocity_B = odometry.velocity_B;
  }

  if (odometry.angular_velocity_B.allFinite() == false) {
    odometry_.angular_velocity_B = previous_odometry.angular_velocity_B;
    ROS_WARN("Odometry.angular_velocity has a non finite element");
  } else {
    odometry_.angular_velocity_B = odometry.angular_velocity_B;
    previous_odometry.angular_velocity_B = odometry.angular_velocity_B;
  }

  odometry_.orientation_W_B = odometry.orientation_W_B;
  previous_odometry.orientation_W_B = odometry.orientation_W_B;

  position_error_ = odometry_.position_W - position_ref_.front(); //Should I use.front()?
  velocity_error_ = odometry_.getVelocityWorld() - velocity_ref_.front();
  attitude_error_ = quat_desired.conjugate()*odometry_.orientation_W_B; //quat multiplication
  angVel_error_ = odometry_.angular_velocity_B; //odometry_.angular_velocity_B - angVel_ref_.front() where angVel_ref is zero 3x1

  if (!received_first_odometry_) {
	  //   Eigen::Vector3d euler_angles;
	  //   odometry.getEulerAngles(&euler_angles);

	  Eigen::VectorXd x0(ACADO_NX);

	  // ADD x0= position error, vel error, orient error,... 13x1 vec !!!
	  x0 << position_error_, velocity_error_, attitude_error_, angVel_error_; // should I insert attitude_error_.w(), attitude_error_.vec()

	  initializeAcadoSolver(x0);

	  //change observer to estimate quaternions??
	  /*  disturbance_observer_.reset(odometry.position_W, odometry.getVelocityWorld(), euler_angles,
	  odometry.angular_velocity_B, Eigen::Vector3d::Zero(),
	  Eigen::Vector3d::Zero()); */

	  received_first_odometry_ = true;
  }
}

void NonlinearModelPredictiveControl::setCommandTrajectoryPoint(
    const mav_msgs::EigenTrajectoryPoint& command_trajectory)
{
  mpc_queue_.insertReference(command_trajectory);
}

void NonlinearModelPredictiveControl::setCommandTrajectory(
    const mav_msgs::EigenTrajectoryPointDeque& command_trajectory)
{
  int array_size = command_trajectory.size();
  if (array_size < 1)
    return;

  mpc_queue_.insertReferenceTrajectory(command_trajectory);
}

void NonlinearModelPredictiveControl::initializeAcadoSolver(Eigen::VectorXd x0)
{
  for (int i = 0; i < ACADO_N + 1; i++) {
    state_.block(i, 0, 1, ACADO_NX) << x0.transpose();
  }

  Eigen::Map<Eigen::Matrix<double, ACADO_NX, ACADO_N + 1>>(const_cast<double*>(acadoVariables.x)) =
      state_.transpose();
  Eigen::Map<Eigen::Matrix<double, ACADO_NU, ACADO_N>>(const_cast<double*>(acadoVariables.u)) =
      input_.transpose();
  Eigen::Map<Eigen::Matrix<double, ACADO_NY, ACADO_N>>(const_cast<double*>(acadoVariables.y)) =
      reference_.transpose();
  Eigen::Map<Eigen::Matrix<double, ACADO_NYN, 1>>(const_cast<double*>(acadoVariables.yN)) =
      referenceN_.transpose();
}

double NonlinearModelPredictiveControl::normalizeForce(double force) {
	return (2 * force - force_max_ - force_min_) / (force_max_ - force_min_);
}

void NonlinearModelPredictiveControl::calculateForcesCommand(
    Eigen::VectorXd* ref_normforces, Eigen::VectorXd* ref_forces)
{
  assert(ref_forces != nullptr);
  assert(initialized_parameters_ == true);
  ros::WallTime starting_time = ros::WallTime::now();

  //Eigen::VectorXd KF_estimated_state;
  Eigen::Vector3d estimated_disturbances;
  Eigen::Matrix<double, ACADO_NX, 1> x_0;

  estimated_disturbances.setZero(kDisturbanceSize);

 // Eigen::Vector3d current_rpy;
 // odometry_.getEulerAngles(&current_rpy);

//  mpc_queue_.updateQueue();
 // mpc_queue_.getQueue(position_ref_, velocity_ref_, acceleration_ref_, yaw_ref_, yaw_rate_ref_);

 /* disturbance_observer_.feedAttitudeCommand(command_roll_pitch_yaw_thrust_);
  disturbance_observer_.feedPositionMeasurement(odometry_.position_W);
  disturbance_observer_.feedVelocityMeasurement(odometry_.getVelocityWorld());
  disturbance_observer_.feedRotationMatrix(odometry_.orientation_W_B.toRotationMatrix());

  bool observer_update_successful = disturbance_observer_.updateEstimator();
  if (!observer_update_successful) {
    disturbance_observer_.reset(odometry_.position_W, odometry_.getVelocityWorld(), current_rpy,
                                Eigen::Vector3d::Zero(), Eigen::Vector3d::Zero(),
                                Eigen::Vector3d::Zero());
  }

  disturbance_observer_.getEstimatedState(&KF_estimated_state);

  if (enable_offset_free_ == true) {
    estimated_disturbances = KF_estimated_state.segment(12, kDisturbanceSize);
  } else {
    estimated_disturbances.setZero(kDisturbanceSize);
  } */

  if (enable_integrator_) {
    Eigen::Vector3d position_error = position_ref_.front() - odometry_.position_W; //should it be odo - ref?
    if (position_error.norm() < antiwindup_ball_) {
      position_error_integration_ += position_error * sampling_time_;
    } else {
      position_error_integration_.setZero();
    }

    position_error_integration_ = position_error_integration_.cwiseMax(
        Eigen::Vector3d(-position_error_integration_limit_, -position_error_integration_limit_,
                        -position_error_integration_limit_));

    position_error_integration_ = position_error_integration_.cwiseMin(
        Eigen::Vector3d(position_error_integration_limit_, position_error_integration_limit_,
                        position_error_integration_limit_));

    estimated_disturbances -= Eigen::Vector3d(Ki_xy_, Ki_xy_, Ki_altitude_).asDiagonal()
        * position_error_integration_;
  }

//  double current_yaw = odometry_.getYaw();

  Eigen::Vector3d estimated_disturbances_B =
      odometry_.orientation_W_B.toRotationMatrix().transpose() * estimated_disturbances;
  
  double u_ref = mass_*kGravity / 4;
  for (size_t i = 0; i < ACADO_N; i++) {
	  /* Eigen::Vector3d acceleration_ref_B = odometry_.orientation_W_B.toRotationMatrix().transpose() * acceleration_ref_[i];

    Eigen::Vector2d feed_forward(
        (-(acceleration_ref_B(1) - estimated_disturbances_B(1)) / kGravity),
        ((acceleration_ref_B(0) - estimated_disturbances_B(0)) / kGravity)); 
		
		reference_.block(i, 0, 1, ACADO_NY) << position_ref_[i].transpose(), velocity_ref_[i].transpose(), feed_forward
        .transpose(), feed_forward.transpose(), acceleration_ref_[i].z() - estimated_disturbances(2); */
 
	  reference_.block(i, 0, 1, ACADO_NY) << 0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0,   u_ref, u_ref, u_ref, u_ref;
      acado_online_data_.block(i, ACADO_NOD - 3, 1, 3) << estimated_disturbances.transpose();
  }

  //referenceN_ << position_ref_[ACADO_N].transpose(), velocity_ref_[ACADO_N].transpose();
  acado_online_data_.block(ACADO_N, ACADO_NOD - 3, 1, 3) << estimated_disturbances.transpose();

  referenceN_ << 0, 0, 0, 0, 0, 0;
  //x_0 << odometry_.getVelocityWorld(), current_rpy, odometry_.position_W;
  x_0 << position_error_, velocity_error_, attitude_error_, angVel_error_; // should I insert attitude_error.w(), attitude_error.vec()

  Eigen::Map<Eigen::Matrix<double, ACADO_NX, 1>>(const_cast<double*>(acadoVariables.x0)) = x_0;
  Eigen::Map<Eigen::Matrix<double, ACADO_NY, ACADO_N>>(const_cast<double*>(acadoVariables.y)) =
      reference_.transpose();
  Eigen::Map<Eigen::Matrix<double, ACADO_NYN, 1>>(const_cast<double*>(acadoVariables.yN)) =
      referenceN_.transpose();
  Eigen::Map<Eigen::Matrix<double, ACADO_NOD, ACADO_N + 1>>(const_cast<double*>(acadoVariables.od)) =
      acado_online_data_.transpose();

  ros::WallTime time_before_solving = ros::WallTime::now();

  acado_preparationStep();

  int acado_status = acado_feedbackStep();

  solve_time_average_ += (ros::WallTime::now() - time_before_solving).toSec() * 1000.0;

  //double roll_ref = acadoVariables.u[0];
  //double pitch_ref = acadoVariables.u[1];
  //double thrust_ref = acadoVariables.u[2];

  double f1 = acadoVariables.u[0];
  double f2 = acadoVariables.u[1];
  double f3 = acadoVariables.u[2];
  double f4 = acadoVariables.u[3];
//  double norm_uref = (u_ref / 5) - 1; 
  double norm_uref = normalizeForce(u_ref);

  if (std::isnan(f1) || std::isnan(f2) || std::isnan(f3) || std::isnan(f4)
      || acado_status != 0) {
    ROS_WARN_STREAM("Nonlinear MPC: Solver failed with status: " << acado_status);
    ROS_WARN("reinitializing...");
    initializeAcadoSolver (x_0);
    *ref_forces << u_ref, u_ref, u_ref, u_ref;
    *ref_normforces << norm_uref, norm_uref, norm_uref, norm_uref;
    return;
  }

  command_f1_f2_f3_f4_ << f1, f2, f3, f4; //do we need to store normalized forces?

  state_ = Eigen::Map<Eigen::Matrix<double, ACADO_N + 1, ACADO_NX, Eigen::RowMajor>>(
      acadoVariables.x);

/*  // yaw controller
  double yaw_error = yaw_ref_.front() - current_yaw;

  if (std::abs(yaw_error) > M_PI) {
    if (yaw_error > 0.0) {
      yaw_error = yaw_error - 2.0 * M_PI;
    } else {
      yaw_error = yaw_error + 2.0 * M_PI;
    }
  }

  double yaw_rate_cmd = K_yaw_ * yaw_error + yaw_rate_ref_.front();  // feed-forward yaw_rate cmd

  if (yaw_rate_cmd > yaw_rate_limit_) {
    yaw_rate_cmd = yaw_rate_limit_;
  }

  if (yaw_rate_cmd < -yaw_rate_limit_) {
    yaw_rate_cmd = -yaw_rate_limit_;
  }

  *ref_attitude_thrust = Eigen::Vector4d(roll_ref, pitch_ref, yaw_rate_cmd, mass_ * thrust_ref);*/

// *ref_forces = Eigen::Vector4d(normalizeForce(f1), normalizeForce(f2), normalizeForce(f3), normalizeForce(f4)); // what is this for?
   *ref_forces << f1, f2, f3, f4;
   *ref_forces << normalizeForce(f1), normalizeForce(f2), normalizeForce(f3), normalizeForce(f4);

  double diff_time = (ros::WallTime::now() - starting_time).toSec();

  if (verbose_) {
    static int counter = 0;
    if (counter > 100) {
      ROS_INFO_STREAM("average solve time: " << solve_time_average_ / counter << " ms");
      solve_time_average_ = 0.0;

      ROS_INFO_STREAM("Controller loop time : " << diff_time*1000.0 << " ms");

      ROS_INFO_STREAM("f1: " << command_f1_f2_f3_f4_(0) << "\t" << "f2 : \t" << command_f1_f2_f3_f4_(1) << "\t" << "f3 : \t" << command_f1_f2_f3_f4_(2) << "\t" << "f4 \t" << command_f1_f2_f3_f4_(3));
      counter = 0;
    }
    counter++;
  }

} 


//void NonlinearModelPredictiveControl::calculateTorqueThrustCommand(
//	Eigen::Vector3d* ref_torque, Eigen::Vector3d* ref_thrust)
//{
//	assert(ref_torque != nullptr);
//	assert(ref_thrust != nullptr);
//	assert(initialized_parameters_ == true);
//	ros::WallTime starting_time = ros::WallTime::now();
//
//	//Eigen::VectorXd KF_estimated_state;
//	//Eigen::Vector3d estimated_disturbances;
//	Eigen::Matrix<double, ACADO_NX, 1> x_0;
//
//	// Eigen::Vector3d current_rpy;
//	// odometry_.getEulerAngles(&current_rpy);
//
//	//  mpc_queue_.updateQueue();
//	// mpc_queue_.getQueue(position_ref_, velocity_ref_, acceleration_ref_, yaw_ref_, yaw_rate_ref_);
//
//	/*disturbance_observer_.feedAttitudeCommand(command_roll_pitch_yaw_thrust_);
//	disturbance_observer_.feedPositionMeasurement(odometry_.position_W);
//	disturbance_observer_.feedVelocityMeasurement(odometry_.getVelocityWorld());
//	disturbance_observer_.feedRotationMatrix(odometry_.orientation_W_B.toRotationMatrix());
//
//	bool observer_update_successful = disturbance_observer_.updateEstimator();
//	if (!observer_update_successful) {
//	disturbance_observer_.reset(odometry_.position_W, odometry_.getVelocityWorld(), current_rpy,
//	Eigen::Vector3d::Zero(), Eigen::Vector3d::Zero(),
//	Eigen::Vector3d::Zero());
//	}
//
//	disturbance_observer_.getEstimatedState(&KF_estimated_state);
//
//	if (enable_offset_free_ == true) {
//	estimated_disturbances = KF_estimated_state.segment(12, kDisturbanceSize);
//	} else {
//	estimated_disturbances.setZero(kDisturbanceSize);
//	}
//
//	if (enable_integrator_) {
//	Eigen::Vector3d position_error = position_ref_.front() - odometry_.position_W;
//	if (position_error.norm() < antiwindup_ball_) {
//	position_error_integration_ += position_error * sampling_time_;
//	} else {
//	position_error_integration_.setZero();
//	}
//
//	position_error_integration_ = position_error_integration_.cwiseMax(
//	Eigen::Vector3d(-position_error_integration_limit_, -position_error_integration_limit_,
//	-position_error_integration_limit_));
//
//	position_error_integration_ = position_error_integration_.cwiseMin(
//	Eigen::Vector3d(position_error_integration_limit_, position_error_integration_limit_,
//	position_error_integration_limit_));
//
//	estimated_disturbances -= Eigen::Vector3d(Ki_xy_, Ki_xy_, Ki_altitude_).asDiagonal()
//	* position_error_integration_;
//	}
//
//	double current_yaw = odometry_.getYaw();
//
//	Eigen::Vector3d estimated_disturbances_B =
//	odometry_.orientation_W_B.toRotationMatrix().transpose() * estimated_disturbances;*/
//
//	double u_ref = mass_*kGravity / 4;
//	for (size_t i = 0; i < ACADO_N; i++) {
//		/* Eigen::Vector3d acceleration_ref_B = odometry_.orientation_W_B.toRotationMatrix().transpose()
//		* acceleration_ref_[i];
//
//		Eigen::Vector2d feed_forward(
//		(-(acceleration_ref_B(1) - estimated_disturbances_B(1)) / kGravity),
//		((acceleration_ref_B(0) - estimated_disturbances_B(0)) / kGravity));
//
//		reference_.block(i, 0, 1, ACADO_NY) << position_ref_[i].transpose(), velocity_ref_[i].transpose(), feed_forward
//		.transpose(), feed_forward.transpose(), acceleration_ref_[i].z() - estimated_disturbances(2); */
//
//		reference_.block(i, 0, 1, ACADO_NY) << 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, u_ref, u_ref, u_ref, u_ref;
//		//  acado_online_data_.block(i, ACADO_NOD - 3, 1, 3) << estimated_disturbances.transpose();
//	}
//
//	//referenceN_ << position_ref_[ACADO_N].transpose(), velocity_ref_[ACADO_N].transpose();
//	//acado_online_data_.block(ACADO_N, ACADO_NOD - 3, 1, 3) << estimated_disturbances.transpose();
//
//	referenceN_ << 0, 0, 0, 0, 0, 0;
//	//x_0 << odometry_.getVelocityWorld(), current_rpy, odometry_.position_W;
//	x_0 << position_error_, velocity_error_, attitude_error_, angVel_error_; // should I insert attitude_error.w(), attitude_error.vec()
//
//	Eigen::Map<Eigen::Matrix<double, ACADO_NX, 1>>(const_cast<double*>(acadoVariables.x0)) = x_0;
//	Eigen::Map<Eigen::Matrix<double, ACADO_NY, ACADO_N>>(const_cast<double*>(acadoVariables.y)) =
//		reference_.transpose();
//	Eigen::Map<Eigen::Matrix<double, ACADO_NYN, 1>>(const_cast<double*>(acadoVariables.yN)) =
//		referenceN_.transpose();
//	Eigen::Map<Eigen::Matrix<double, ACADO_NOD, ACADO_N + 1>>(const_cast<double*>(acadoVariables.od)) =
//		acado_online_data_.transpose();
//
//	ros::WallTime time_before_solving = ros::WallTime::now();
//
//	acado_preparationStep();
//
//	int acado_status = acado_feedbackStep();
//
//	solve_time_average_ += (ros::WallTime::now() - time_before_solving).toSec() * 1000.0;
//
//	//double roll_ref = acadoVariables.u[0];
//	//double pitch_ref = acadoVariables.u[1];
//	//double thrust_ref = acadoVariables.u[2];
//
//	double f1 = acadoVariables.u[0];
//	double f2 = acadoVariables.u[1];
//	double f3 = acadoVariables.u[2];
//	double f4 = acadoVariables.u[3];
//
//	if (std::isnan(f1) || std::isnan(f2) || std::isnan(f3) || std::isnan(f4)
//		|| acado_status != 0) {
//		ROS_WARN_STREAM("Nonlinear MPC: Solver failed with status: " << acado_status);
//		ROS_WARN("reinitializing...");
//		initializeAcadoSolver(x_0);
//		*ref_thrust << 0, 0, 4*u_ref;
//		*ref_torque << 0, 0, 0;
//
//		return;
//	}
//
//	double armlength = 0.5;
//	double total_thrust = f1 + f2 + f3 + f4;
//	double roll_moment = (f4 - f2)*armlength;
//	double pitch_moment = (f3 - f1)*armlength;
//	double yaw_moment = drag_coefficient_*(-f1 + f2 - f3 + f4);
//
//
//	command_f1_f2_f3_f4_ << f1, f2, f3, f4;
//	command_thrust_ << 0, 0, total_thrust;
//	command_torque_ << roll_moment, pitch_moment, yaw_moment;
//
//	state_ = Eigen::Map<Eigen::Matrix<double, ACADO_N + 1, ACADO_NX, Eigen::RowMajor>>(
//		acadoVariables.x);
//
//	/*  // yaw controller
//	double yaw_error = yaw_ref_.front() - current_yaw;
//
//	if (std::abs(yaw_error) > M_PI) {
//	if (yaw_error > 0.0) {
//	yaw_error = yaw_error - 2.0 * M_PI;
//	} else {
//	yaw_error = yaw_error + 2.0 * M_PI;
//	}
//	}
//
//	double yaw_rate_cmd = K_yaw_ * yaw_error + yaw_rate_ref_.front();  // feed-forward yaw_rate cmd
//
//	if (yaw_rate_cmd > yaw_rate_limit_) {
//	yaw_rate_cmd = yaw_rate_limit_;
//	}
//
//	if (yaw_rate_cmd < -yaw_rate_limit_) {
//	yaw_rate_cmd = -yaw_rate_limit_;
//	}
//
//	*ref_attitude_thrust = Eigen::Vector4d(roll_ref, pitch_ref, yaw_rate_cmd, mass_ * thrust_ref);*/
//
//	*ref_thrust = Eigen::Vector3d(0, 0, total_thrust); // what is this for?
//	*ref_torque = Eigen::Vector3d(roll_moment, pitch_moment, yaw_moment); // what is this for
//
//	double diff_time = (ros::WallTime::now() - starting_time).toSec();
//
//	if (verbose_) {
//		static int counter = 0;
//		if (counter > 100) {
//			ROS_INFO_STREAM("average solve time: " << solve_time_average_ / counter << " ms");
//			solve_time_average_ = 0.0;
//
//			ROS_INFO_STREAM("Controller loop time : " << diff_time*1000.0 << " ms");
//
//			ROS_INFO_STREAM(
//				"f1: " << command_f1_f2_f3_f4_(0) << "\t" << "f2 : \t" << command_f1_f2_f3_f4_(1) << "\t" << "f3 : \t" << command_f1_f2_f3_f4_(2) << "\t" << "f4 : \t" << command_f1_f2_f3_f4_(3);
//			counter = 0;
//		}
//		counter++;
//	}
//
//}

/*Eigen::MatrixXd NonlinearModelPredictiveControl::solveCARE(Eigen::MatrixXd Q, Eigen::MatrixXd R)
{
  // Define system matrices
  Eigen::MatrixXd A;
  A.resize(6, 6);
  A.setZero();

  A.block(0, 3, 3, 3) = Eigen::Matrix3d::Identity();
  A.block(3, 3, 3, 3) = -1.0 * drag_coefficients_.asDiagonal();

  Eigen::MatrixXd B;
  B.resize(6, 3);
  B.setZero();

  B(3, 1) = kGravity;
  B(4, 0) = -1.0 * kGravity;
  B(5, 2) = 1.0;

  Eigen::MatrixXd G = B * R.inverse() * B.transpose();

  Eigen::MatrixXd z11 = A;
  Eigen::MatrixXd z12 = -1.0 * G;
  Eigen::MatrixXd z21 = -1.0 * Q;
  Eigen::MatrixXd z22 = -1.0 * A.transpose();

  Eigen::MatrixXd Z;
  Z.resize(z11.rows() + z21.rows(), z11.cols() + z12.cols());
  Z << z11, z12, z21, z22;

  int n = A.cols();
  Eigen::MatrixXd U(2 * n, 2 * n);  // Orthogonal matrix from Schur decomposition
  Eigen::VectorXd WR(2 * n);
  Eigen::VectorXd WI(2 * n);
  lapack_int sdim = 0;  // Number of eigenvalues for which sort is true
  lapack_int info;
  info = LAPACKE_dgees(LAPACK_COL_MAJOR,  // Eigen default storage order
      'V',               // Schur vectors are computed
      'S',               // Eigenvalues are sorted
      select_lhp,        // Ordering callback
      Z.rows(),          // Dimension of test matrix
      Z.data(),          // Pointer to first element
      Z.rows(),          // Leading dimension (column stride)
      &sdim,             // Number of eigenvalues sort is true
      WR.data(),         // Real portion of eigenvalues
      WI.data(),         // Complex portion of eigenvalues
      U.data(),          // Orthogonal transformation matrix
      Z.rows());         // Dimension of Z

  Eigen::MatrixXd U11 = U.block(0, 0, n, n).transpose();
  Eigen::MatrixXd U21 = U.block(n, 0, n, n).transpose();

  return U11.jacobiSvd(Eigen::ComputeThinU | Eigen::ComputeThinV).solve(U21).transpose();
}*/


bool NonlinearModelPredictiveControl::getCurrentReference(
    mav_msgs::EigenTrajectoryPoint* reference) const
{
  assert(reference != nullptr);

  (*reference).position_W = position_ref_.front();
  (*reference).velocity_W = velocity_ref_.front();
  (*reference).acceleration_W = acceleration_ref_.front();
 // (*reference).angular_velocity_W = angVel_ref_.front(); //shouldnt reference have angular_velocity_B? odometry_.orientation_W_B.toRotationMatrix() * angVel_ref_.front()
  (*reference).setFromYaw(yaw_ref_.front());
 // (*reference).setFromYaw(yaw_ref_);

  return true;
}

bool NonlinearModelPredictiveControl::getCurrentReference(
    mav_msgs::EigenTrajectoryPointDeque* reference) const
{
  assert(reference != nullptr);

  (*reference).clear();

  for (size_t i = 0; i < position_ref_.size(); i++) {
    mav_msgs::EigenTrajectoryPoint pnt;
    pnt.position_W = position_ref_.at(i);
    pnt.velocity_W = velocity_ref_.at(i);
    pnt.acceleration_W = acceleration_ref_.at(i);
//	pnt.angular_velocity_W = angVel_ref_.at(i);
    pnt.setFromYaw(yaw_ref_.at(i));
    (*reference).push_back(pnt);
  }
  return true;
}

bool NonlinearModelPredictiveControl::getPredictedState(
    mav_msgs::EigenTrajectoryPointDeque* predicted_state) const
{
  assert(predicted_state != nullptr);

  for (size_t i = 0; i < ACADO_N + 1; i++) {
    mav_msgs::EigenTrajectoryPoint pnt;
    pnt.position_W = state_.block(i, 0, 1, 3).transpose();
    (*predicted_state).push_back(pnt);
  }

  return true;
}



/*Eigen::Quaterniond NonlinearModelPredictiveControl::quatMult(Eigen::Quaterniond q1, Eigen::Quaterniond q2) {
	Eigen::Quaterniond resultQ;
	resultQ.setIdentity();

	resultQ.w() = q1.w() * q2.w() - q1.vec().dot(q2.vec());
	resultQ.vec() = q1.w() * q2.vec() + q2.w() * q1.vec() + q1.vec().cross(q2.vec());

	return resultQ;
}*/


}
